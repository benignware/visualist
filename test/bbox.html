<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <script src="XCSSMatrix.js"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <svg style="border: none" id="svg" xmlns="http://www.w3.org/2000/svg" version="1.2"  width="800" height="600" viewbox="0 0 800 600">
      <g id="layer" transform="translate(100,10) rotate(45) scale(1) skewX(20)">
        <!--<text id="svgtext" x="150" y="150" style="font-size: 30px; font-family: Arial" text-anchor="start" dy="0">Visualist</text>-->
        
        
        <!--
          <rect x="50" y="20" width="100" height="50"> </rect>
        <circle cx="170" cy="20" r="50"> </circle>
        <ellipse cx="250" cy="-100" rx="20" ry="50"></ellipse>-->
        <!--<line x1="170" y1="-50" x2="350" y2="10" stroke="red"> </line>-->
        
        <text x="0" y="100">
          <tspan>Hello World!</tspan>
          <tspan x="0" dy="20">Visualistccccc</tspan>
          <tspan x="0" dy="20">Visualistccccc</tspan>
        </text>
        
      </g>
    </svg>
    <script>
      var svg = document.getElementById('svg');
      
      function SVGPoint(x, y) {
        this.x = parseFloat(x);
        this.y = parseFloat(y);
      }
      
      SVGPoint.prototype.matrixTransform = function(matrix) {
        var px = this.x * matrix.a + this.y * matrix.c + matrix.e;
        var py = this.x * matrix.b + this.y * matrix.d + matrix.f;
        return new SVGPoint(px, py);
      };
      
      function parseValue(value) {
        return parseFloat(value);
      }
      
      var getPoints = (function() {
        
        var currentTextPosition = null;
        
        function getPoints(node) {
          var points = [];
          
          // Shapes
          if (node.nodeName === 'line') {
            var x1 = parseValue(node.getAttribute('x1'));
            var y1 = parseValue(node.getAttribute('y1'));
            var x2 = parseValue(node.getAttribute('x2'));
            var y2 = parseValue(node.getAttribute('y2'));
            points.push(new SVGPoint(x1, y1), new SVGPoint(x2, y2));
          }
  
          if (node.nodeName === 'rect') {
            var x1 = parseValue(node.getAttribute('x'));
            var y1 = parseValue(node.getAttribute('y'));
            var x2 = x1 + parseValue(node.getAttribute('width'));
            var y2 = y1 + parseValue(node.getAttribute('height'));
            points.push(new SVGPoint(x1, y1), new SVGPoint(x2, y1), new SVGPoint(x2, y2), new SVGPoint(x1, y2));
          }
          
          if (node.nodeName === 'circle') {
            var cx = parseValue(node.getAttribute('cx'));
            var cy = parseValue(node.getAttribute('cy'));
            var r = parseValue(node.getAttribute('r'));
            var l = Math.floor(Math.PI * 2 * r);
            var t = Math.PI * 2 / r;
            points = points.concat(Array.apply(null, Array(l)).map(function(value, index) {
              var a = t * index;
              var x = cx + Math.cos(a) * r;
              var y = cy + Math.sin(a) * r;
              return new SVGPoint(x, y);
            }));
            points.push(new SVGPoint(cx, cy - r), new SVGPoint(cx + r, cy), new SVGPoint(cx, cy + r), new SVGPoint(cx - r, cy));
          }
  
          if (node.nodeName === 'ellipse') {
            var cx = parseValue(node.getAttribute('cx'));
            var cy = parseValue(node.getAttribute('cy'));
            var rx = parseValue(node.getAttribute('rx'));
            var ry = parseValue(node.getAttribute('ry'));
            var l = Math.floor(Math.PI * 2 * Math.sqrt((rx * rx) + (ry + ry)));
            var t = Math.PI * 2 / l;
            points = points.concat(Array.apply(null, Array(l)).map(function(value, index) {
              var a = t * index;
              var x = cx + Math.cos(a) * rx;
              var y = cy + Math.sin(a) * ry;
              return new SVGPoint(x, y);
            }));
          }
          
          if (node.nodeName === 'text') {
            currentTextPosition = null;
          }
          
          if (node.nodeType === 3 && node.data.trim()) {
            var elem, x = NaN, y = NaN, dx = NaN, dy = NaN;
            
            // Get absolute position
            elem = node;
            while ((elem = elem.parentNode) && (elem.nodeName === 'text' || elem.nodeName === 'tspan') && (isNaN(x) || isNaN(y))) {
              if (elem.nodeName === 'text' && currentTextPosition) {
                if (isNaN(x)) {
                  x = currentTextPosition.x;
                }
                if (isNaN(y)) {
                  y = currentTextPosition.y;
                }
              }
              x = isNaN(x) ? parseValue(elem.getAttribute('x')) : x;
              y = isNaN(y) ? parseValue(elem.getAttribute('y')) : y;
            }
            x = isNaN(x) ? 0 : x;
            y = isNaN(y) ? 0 : y;
            
            // Shift by relative position
            elem = node;
            while ((elem = elem.parentNode) && (elem.nodeName === 'text' || elem.nodeName === 'tspan') && (isNaN(dx) || isNaN(dy))) {
              dx = isNaN(dx) ? parseValue(elem.getAttribute('dx')) : dx;
              dy = isNaN(dy) ? parseValue(elem.getAttribute('dy')) : dy;
            }
            dx = isNaN(dx) ? 0 : dx;
            dy = isNaN(dy) ? 0 : dy;
            
            x+= dx;
            y+= dy;
            
            // Calculate text dimensions
            var elem = node.parentNode;
            var style = getComputedStyle(elem);
            var fontSize = parseFloat(style.fontSize);
            var w = elem.getComputedTextLength();
            var h = fontSize;

            // Add bounding points
            points.push(new SVGPoint(x, y), new SVGPoint(x + w, y), new SVGPoint(x + w, y - h), new SVGPoint(x, y - h));
            
            // Update current text position
            currentTextPosition = new SVGPoint(x + w, y);
          }
          
          // Apply transformations
          if (node.nodeType === 1) {
            for (var i = 0; i < node.childNodes.length; i++) {
              var child = node.childNodes[i];
              var childPoints = getPoints(child);
              if (child.nodeType === 1) {
                var transform = child.getAttribute('transform');
                var matrix = new XCSSMatrix(transform);
              }
              points = points.concat(childPoints.map(function(point) {
                return matrix ? point.matrixTransform(matrix) : point;
              }));
            }
          }
          
          // Reset current text position
          if (node.nodeName === 'text') {
            currentTextPosition = null;
          }
          
          return points;
        }
        
        
        return getPoints;
      })();
      
      
      
      function getBBox(elem) {
        
        //return elem.getBBox();
        
        var points = getPoints(elem);
        
        console.log("points: ", points);
        
        var x1, y1, x2, y2;
        points.forEach(function(point) {
          x1 = typeof x1 === 'undefined' ? point.x : Math.min(point.x, x1);
          y1 = typeof y1 === 'undefined' ? point.y : Math.min(point.y, y1);
          x2 = typeof x2 === 'undefined' ? point.x : Math.max(point.x, x2);
          y2 = typeof y2 === 'undefined' ? point.y : Math.max(point.y, y2);
        });
        
        return {
          x: x1 || 0,
          y: y1 || 0,
          width: (x2 - x1) || 0,
          height: (y2 - y1) || 0
        };
      }
      
      
      var bbox = getBBox(svg);
      
      
      console.log("svg: ", svg, bbox);
      var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute("x", bbox.x);
      rect.setAttribute("y", bbox.y);
      rect.setAttribute("width", bbox.width);
      rect.setAttribute("height", bbox.height);
      
      rect.setAttribute("fill", 'transparent');
      rect.setAttribute("stroke", 'blue');
      rect.setAttribute("stroke-width", '2px');
      //svg.insertBefore(rect, svg.firstChild);
      svg.appendChild(rect);
      
      
      
      
    </script>
  </body>
</html>